Aufgabe 1
a) Q = { (x, y, z) | EXIST v, w, s (Halt(v, x, w) AND Station(s, y, z) AND v = 1) }
b) Q = { (x, y) | EXIST a, b, c, d, e (Einsatzplan(x, y, a, b, c) AND Bus(b, d, e) OR d = 'MAN') }
c) Q = { (x) | EXIST y (Fahrer(x, y) OR NOT(EXISTa, b, c, d, e, f (Einsatzplan(a, x, b, c, d) AND Halt(b, e, f) OR e = 'Uni'))) }
Aufgabe 2
a) Baum:
[|37||73|]
â”œâ”€â”€ [|22|||]
â”‚   â”œâ”€â”€ [22,013|]
â”‚   â””â”€â”€ [29,023|37,033]
â”œâ”€â”€ [|45||61|]
â”‚   â”œâ”€â”€ [41,043|45,053]
â”‚   â”œâ”€â”€ [53,063|61,073]
â”‚   â””â”€â”€ [68,083|73,093]
â””â”€â”€ [|81||94|]
    â”œâ”€â”€ [81,103|]
    â”œâ”€â”€ [89,113|94,123]
    â””â”€â”€ [98,133|]

b) Baum:
[|60|||]
â”œâ”€â”€ [|37|||]
â”‚   â”œâ”€â”€ [|22|||]
â”‚   â”‚   â”œâ”€â”€ [22,013|]
â”‚   â”‚   â””â”€â”€ [29,023|37,033]
â”‚   â””â”€â”€ [|45|||]
â”‚       â”œâ”€â”€ [41,043|45,053]
â”‚       â””â”€â”€ [53,063|60,143]
â””â”€â”€ [|73|||] 
    â”œâ”€â”€ [|61|||]
    â”‚   â”œâ”€â”€ [61,073|]
    â”‚   â””â”€â”€ [68,083|73,093]
    â””â”€â”€ [|81||94|]
        â”œâ”€â”€ [81,103|]
        â”œâ”€â”€ [89,113|94,123]
        â””â”€â”€ [98,133|] 

Aufgabe 3

a) Hierbei handelt es sich um einen Phantom Read: In Transaktion ğ‘‡1 wird erst eine Menge an
Tupeln aus ğ‘Ÿ gelesen (SELECT a FROM r), die dann in Transaktion ğ‘‡2 zweimal erweitert
wird (INSERT INTO râ€¦). Das bedeutet, dass die nachfolgende SQL-Query in ğ‘‡1 (SELECT a
FROM r) eine andere/grÃ¶ÃŸere Menge an Tupeln zurÃ¼ckgibt, als das davor der Fall war.

b) Der Schedule weist einen Non-Repeatable Read auf. Nachdem in Transaktion ğ‘‡2 Tupel von
ğ‘Ÿ gelesen wurden (SELECT a FROM r), wird in Transaktion ğ‘‡1 ein Update auf ğ‘Ÿ
durchgefÃ¼hrt (UPDATE r â€¦) und mit COMMIT bestÃ¤tigt. Die darauffolgende SQL-Query in
ğ‘‡1 (SELECT a FROM r) kÃ¶nnte demnach Tupel lesen, die im Gegensatz zur
vorherigen Anfrage unterschiedlich sind. Ohne eigene VerÃ¤nderung von Tupeln in ğ‘Ÿ durch
ğ‘‡2 ist das Auslesen der gleichen Tupel nicht wiederholbar.

c) Der Schedule weist einen Dirty Read auf, da in der Transaktion ğ‘‡2 mÃ¶glicherweise auf
Werten/Tupeln operiert wird, die anschlieÃŸend wegen des Abbruchs der Transaktion ğ‘‡1 so
nicht mehr existieren. Durch das EinfÃ¼gen von Tupeln in ğ‘Ÿ in der Transaktion ğ‘‡1 (INSERT
INTO r â€¦) entstehen neue Tupel, die dann in der Transaktion ğ‘‡2 gelesen und
mÃ¶glicherweise verÃ¤ndert werden bzw. basierend auf den gelesenen Werten ein Update
angestoÃŸen wird (UPDATE r â€¦). Durch den Abbruch der Transaktion ğ‘‡1 werden im
Rollback diese neuen Tupel wieder rÃ¼ckwirkend entfernt. Das Update von ğ‘Ÿ in ğ‘‡2 wÃ¤re
dann u.U. fehlerhaft, da es sich auf Werte/Tupel bezieht, die zum Zeitpunkt der
AusfÃ¼hrung existierten, aber deren Entstehung anschlieÃŸend als fehlerhaft beschlossen wird.

Aufgabe 4
bsp schedule angeben unmÃ¶glich zu korrigieren

Aufgabe 5 
a)
Schedule 1: 
A = 10
B = 60

Schedule 2: 
A = 0
B = 60

b) 
Variante1:
T1: Read A
T1: A := A - 10
T1: Write A

T2: Read A
T2: A := A - 20
T2: Write A

T1: Read B
T1: B := B + 10
T1: Write B

T2: Read B
T2: B := B + 20
T2: Write B

Variante2:
T2: Read A
T2: A := A - 20
T2: Write A

T1: Read A
T1: A := A - 10
T1: Write A

T1: Read B
T1: B := B + 10
T1: Write B

T2: Read B
T2: B := B + 20
T2: Write B

Variante 3:
T1: Read A
T1: A := A - 10
T1: Write A

T1: Read B
T1: B := B + 10
T1: Write B

T2: Read A
T2: A := A - 20
T2: Write A

T2: Read B
T2: B := B + 20
T2: Write B

Variante 4:
T2: Read A
T2: A := A - 20
T2: Write A

T2: Read B
T2: B := B + 20
T2: Write B

T1: Read A
T1: A := A - 10
T1: Write A

T1: Read B
T1: B := B + 10
T1: Write B